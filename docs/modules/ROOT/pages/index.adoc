= AcrossHibernateJpaModule
Arne Vandamme
3.0.0.RELEASE
:toc: left
:toclevels: 3
:sectanchors:
:module-version: 3.0.0.RELEASE
:module-name: AcrossHibernateJpaModule
:module-artifact: across-hibernate-module
:module-url: https://across.foreach.be/modules/AcrossHibernateJpaModule
:entity-module-url: https://across.foreach.be/modules/EntityModule

[copyright,verbatim]
--
Copyright (C) 2014-2018 +
[small]#Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.#
--

[abstract]
== About
The {module-artifact} artifact actually contains 2 Across modules: *AcrossHibernateJpaModule* and *AcrossHibernateModule*.

*AcrossHibernateJpaModule* activates JPA support for the entire Across context.
It allows other module to subscribe their entities to the JPA `EntityManager` represented by the AcrossHibernateJpaModule.
The JPA implementation is built on top of Hibernate.
The module also activates support for Spring Data `JpaRepository` implementations and comes with a set of <<base-classes,helpers>> to facilitate repository implementations.

In an Across application with a single entity manager, adding AcrossHibernateJpaModule will serve as a drop-in replacement for the regular Spring Boot JPA starter in the application module.

The older *AcrossHibernateModule* is still kept for historical compatibility, but does not support JPA nor Spring Data repositories.
It has been deprecated and should no longer be used.

Module website: {module-url}

:numbered:
== General information

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across.modules</groupId>
			<artifactId>{module-artifact}</artifactId>
			<version>{module-version}</version>
		</dependency>
	</dependencies>
----

=== Module dependencies
{module-name} does not have any dependencies on other modules.

[[module-settings]]
=== Module settings
AcrossHibernateJpaModule supports the following properties:
[source,properties]
----
# APPLICATION MODULE SUPPORT
acrossHibernate.application.entity-scan= # Scan for entities in the application module. Defaults to true if only one JPA module detected.
acrossHibernate.application.repository-scan= # Enable Spring Data JPA repositories in the application module. Defaults to true if only one JPA module detected.

# JPA/HIBERNATE
acrossHibernate.primary= # Mark the exposed beans as primary in the Across context. Default is true for the AcrossHibernateJpaModule or if only a single JPA module.
acrossHibernate.data-source= # Name of the DataSource bean that should be resolved and used for the entity manager.
acrossHibernate.persistence-unit-name= # Name of the persistence unit this EntityManager represents. Defaults to the module name.
acrossHibernate.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the "databasePlatform" property.
acrossHibernate.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the "Database" enum.
acrossHibernate.generate-ddl=false # Initialize the schema on startup.
acrossHibernate.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto" property. Default to "none".
acrossHibernate.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.
acrossHibernate.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.
acrossHibernate.hibernate.use-new-id-generator-mappings= # Use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.
acrossHibernate.properties.*= # Additional native properties to set on the JPA provider.
acrossHibernate.show-sql=false # Enable logging of SQL statements.
acrossHibernate.create-unit-of-work-factory=false # Create and expose a UnitOfWorkFactory.
acrossHibernate.register-repository-interceptor=true # Enable EntityInterceptor support in Spring Data JpaRepository implementations.

# WEB SUPPORT
acrossHibernate.open-in-view=true # Register an open-in-view handler. Binds a JPA EntityManager to the thread for the entire processing of the request.
acrossHibernate.persistenceContextInView.handler=FILTER # Type of open-in-view handler that should be created.
acrossHibernate.persistenceContextInView.order= # Order of the open-in-view handler. Defaults to 'HIGHEST_PRECEDENCE + 1'.

# TRANSACTION
acrossHibernate.transaction.default-timeout= # Default transaction timeout in seconds.
acrossHibernate.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.
----

[discrete]
==== Spring Boot properties fallback
The default AcrossHibernateJpaModule will also respect the default Spring Boot JPA and transaction related properties.
However, values configured using the `acrossHibernate` prefix will always take precedence.

Mapping the original Spring Boot properties allows for easy migration of an Across application using the default JPA starter, to one backed by the AcrossHibernateJpaModule.
In the best case the developer will not have to make any property changes.

.Spring Boot properties mapped to AcrossHibernateJpaModuleSettings
[source,properties]
----
# JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)
spring.data.jpa.repositories.enabled=true # Enable JPA repositories in the application module.
spring.jpa.database= # Target database to operate on, auto-detected by default. Can be alternatively set using the "databasePlatform" property.
spring.jpa.database-platform= # Name of the target database to operate on, auto-detected by default. Can be alternatively set using the "Database" enum.
spring.jpa.generate-ddl=false # Initialize the schema on startup.
spring.jpa.hibernate.ddl-auto= # DDL mode. This is actually a shortcut for the "hibernate.hbm2ddl.auto" property. Default to "none".
spring.jpa.hibernate.naming.implicit-strategy= # Hibernate 5 implicit naming strategy fully qualified name.
spring.jpa.hibernate.naming.physical-strategy= # Hibernate 5 physical naming strategy fully qualified name.
spring.jpa.hibernate.use-new-id-generator-mappings= # Use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.
spring.jpa.open-in-view=true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.
spring.jpa.properties.*= # Additional native properties to set on the JPA provider.
spring.jpa.show-sql=false # Enable logging of SQL statements.

# TRANSACTION (TransactionProperties)
spring.transaction.default-timeout= # Default transaction timeout in seconds.
spring.transaction.rollback-on-commit-failure= # Perform the rollback on commit failures.
----

NOTE: A custom module will never map the original Spring Boot properties.

== What's new in this version?
:numbered!:

=== 3.0.0.RELEASE
This version requires Across 3.0.0.
It is also a major update increasing compatibility with the Spring Boot JPA starter.

The default configuration now builds on top of Spring Boot JPA support.

.Naming strategy
Due to Spring Boot compatibility, the default naming strategy being used has been changed since the previous version: the default is now a Spring naming strategy, instead of a Hibernate one.
This can cause problems with query generation.

Some issues have been mentioned regarding reserved keywords (eg. as a table or column name).

You can manually revert to the previous naming strategy by setting: `acrossHibernate.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl`.

.List of changes
* when plugging a single AcrossHibernateJpaModule in an application it will transparently take over the starter JPA support on the application module
** the single exception is the default handling of schema creation in case of a memory database: standard Spring Boot will create the schema by default whereas AcrossHibernateJpaModule will not
* a `PlatformTransactionManager` is now always created
** the (largely unused) configuration property to disable the `PlatformTransactionManager` has been removed
* in addition a `TransactionTemplate` bean is now also created and exposed
* the AcrossHibernateJpaModule will mark its exposed beans as `@Primary` by default
** if you want another module to expose the primary beans, set the property `acrossHibernate.primary` to `false`
** a custom module (eg. extending AcrossHibernateJpaModule) works the opposite way: it will not expose primary beans unless the relevant property is explicitly set to `true` or it is the only module in the Across context
* several new <<module-settings,configurable properties>> have been added
** all `spring.jpa` and `spring.transaction` configuration properties will be respected, they can also be set directly using the `acrossHibernate` prefix
* it is now much easier to <<multiple-modules,create a separate AcrossHibernateJpaModule>> for an additional `EntityManager`
** using `AcrossHibernateJpaModule.builder()` a custom module can now also be created at runtime
** property handling for custom modules is much easier
* it's now also possible to specify packages to scan for entities by injecting an `@EntityScan` annotated class into the AcrossHibernateJpaModule
* fix compatibility with Spring Data which changes the signature of `JpaRepositoryFactoryBean`

NOTE: The original AcrossHibernateModule is still present but has officially been deprecated.

=== 2.0.1.RELEASE
* fix Spring Boot relaxed binding support for *acrossHibernate.* properties

=== 2.0.0.RELEASE
* Compatibility update with Spring 4.2 which adds two new attributes to `@EnableAcrossJpaRepositories`.
* `<<EntityInterceptor>>` calls will now run in the same transaction as the repository methods, if no outer transaction is active yet, a new one will be created

=== 1.1.1.RELEASE
* most settings are now configurable through properties with Spring configuration metadata support
* the <<HibernatePackage,hibernate package>> can now be configured adding a `HibernatePackageConfigurer` via `@ModuleConfiguration`

=== 1.1.0.RELEASE
Major addition of the new `AcrossHibernateJpaModule` as a replacement for the legacy `AcrossHibernateModule`.

* JPA and Spring Data repositories support
* `AuditableSchemaInstaller` refactored to support multiple tables
* Addition of a `HibernateSessionHolder` bean to facilitate migration to the JPA module

=== 1.0.0.RELEASE
Initial public release available on http://search.maven.org/[Maven central].

:numbered:
== Using AcrossHibernateJpaModule

=== Application module support
The {module-name} builds a JPA `EntityManager` for a Persistence Unit with the same name, using Hibernate as the implementation engine.
Other modules can configure mappings in the `EntityManager` by adding them to the <<HibernatePackage,HibernatePackage>> that the AcrossHibernateJpaModule handles.

The AcrossHibernateJpaModule serves as an alternative for using the `spring-boot-starter-data-jpa` in a multi-module application.

Using an `@AcrossApplication` with `across-autoconfigure` and `spring-boot-starter-data-jpa`, you might have JPA enabled in your application module.
The latter however does not easily allow shared Across modules to attach to the same `EntityManager`.

In an Across application module, using AcrossHibernateJpaModule should not necessarily require any changes.
If you simply add AcrossHibernateJpaModule to your application configuration, it will transparently replace the `spring-boot-starter-data-jpa` functionality:

* the single datasource will be used
* the entire application module will be scanned for entities
* Spring Data JPA repositories in the application module will be activated
** compared to the default JPA starter, the AcrossHibernateJpaModule will also enable <<EntityInterceptor,entity intercepting support>>
* a single `PlatformTransactionManager` with the default name will be available

Most of the default behaviour can be controlled using the <<module-settings,module settings>>.
If you do not want to use the default entity scan or Spring Data repository scan, you should treat the application module as if it is a shared module and <<manual-configuration,register your entities manually>>.

AcrossHibernateJpaModule also makes it easier to work with <<multiple-modules,multiple entity managers>> in a single application.

[[manual-configuration]]
=== Manual configuration
In a simple application the developer probably has to do nothing to make use of the `EntityManager` provided by the AcrossHibernateJpaModule.
If you want to use the `EntityManager` in a shared module, there's a couple of steps involved:

. Add a required dependency from your module to AcrossHibernateJpaModule using fi `@AcrossDepends(required="AcrossHibernateJpaModule")`
. <<HibernatePackage,Register the entities>> that should be managed by the shared `EntityManager`
. Configure the <<spring-data-repositories,Spring Data JPA repositories>> for you module

AcrossHibernateJpaModule always creates a `PlatformTransactionManager` and enables transaction management support in all modules bootstrapping later.
When having <<multiple-modules,multiple JPA modules>> in a single application, you will have multiple transaction managers and you will have to specify which one to use.

==== Specifying the datasource
By default the AcrossHibernateJpaModule will use the main Across context datasource for the mapping context.
It does so by looking for a datasource bean named `acrossDataSource`.

You can specify a different datasource bean to use by setting the `acrossHibernate.data-source` property value.

Alternatively, you can also create the `AcrossHibernateJpaModule` instance manually and provide a `DataSource` in the constructor.
This will always take precedence over any configured property.

[source,java]
----
@Bean
public AcrossHibernateJpaModule acrossHibernateJpaModule( DataSource myDataSource ) {
  return new AcrossHibernateJpaModule( myDataSource );
}
----

[[HibernatePackage]]
==== Registering entities
AcrossHibernateJpaModule creates a Hibernate backed `EntityManager` for the classes assigned to it.
Modules should tell the AcrossHibernateJpaModule where to scan for entities.
The easiest way to do this is to register a module extension in the AcrossHibernateJpaModule with an `@EntityScan` for the correct packages.

.Registering entities code implementing a HibernatePackageConfigurer
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@ModuleConfiguration(AcrossHibernateJpaModule.NAME)
@EntityScan( basePackageClasses = MyEntities.class )
public class MyEntitiesConfiguration {
}
----

The location of `MyEntitiesConfiguration` in the above example would usually be in the `extensions` child package of that module's root package.

.Application module support
The application module is automatically scanned for entities if either of the following applies:

* there is only the default `AcrossHibernateJpaModule` and property `acrossHibernate.application.entity-scan` is not `false`
* property `acrossHibernate.application.entity-scan` is `true`

.Advanced configuration
Apart from using `@EntityScan` there are different ways to register entities with AcrossHibernateJpaModule.
To determined the entities it managed, any AcrossHibernateJpaModule creates a `HibernatePackage` with the same name as the module itself (AcrossHibernateJpaModule by default).

This package determines the entire mapping context that is available in the `EntityManager`.
When bootstrapping, the AcrossHibernateJpaModule will delegate configuration to all `HibernatePackageConfigurer` beans found, followed by looking for `@EntityScan` annotated classes in its module context.
As such, consuming modules can also inject a `HibernatePackageConfigurer` implementation into the JPA module using `@ModuleConfiguration`.

.Example code using a HibernatePackageConfigurer
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@ModuleConfiguration(AcrossHibernateJpaModule.NAME)
public class UserEntitiesConfiguration implements HibernatePackageConfigurer
{
	@Override
	public void configureHibernatePackage( HibernatePackageRegistry hibernatePackage ) {
		hibernatePackage.addPackageToScan( "com.foreach.across.modules.user.business" );
	}
}
----

The `HibernatePackageConfigurer` exposes the `HibernatePackageRegistry` which also allows you to register XML-based resources.

NOTE: Unlike with `@EntityScan` the same configurer class can also be injected into multiple JPA modules.
The `HibernatePackageRegistry.getName()` can then be used to discriminate between mapping contexts.

==== Configure JPA properties
Custom JPA or Hibernate properties can be set using the <<module-settings,module settings>>.
AcrossHibernateJpaModule will attempt to detect sensible defaults, but you can manually set most properties if you prefer.

.Example JPA property configuration
[source,properties]
----
acrossHibernate.show-sql=true   # Show SQL statements
acrossHibernate.database=SQL_SERVER # Manually specify the database type for the Hibernate dialect
----

Setting `acrossHibernate.generate-ddl=true` will enable automatic schema creation using Hibernate `hbm2ddl.auto=update` value.
If you want to be more specific you can set the Hibernate value using `acrossHibernate.hibernate.ddl-auto`.
Unlike the Spring Boot default behaviour, AcrossHibernateJpaModule will *never* automatically enable schema creation, not even for embedded databases.

All properties passed to `acrossHibernate.properties.*` are passed through as Hibernate configuration properties (without the prefix).
They will also replace any possibly generated property values if they match.

NOTE: The default AcrossHibernateJpaModule also supports the `spring.jpa.*` properties.

[[spring-data-repositories]]
==== Using Spring Data JPA Repositories
Use *`@EnableAcrossJpaRepositories`* in your modules to generate JPA repositories attaching to the default AcrossHibernateJpaModule `EntityManager`.
This is a full equivalent of `@EnableJpaRepositories` but it automatically select the default `PlatformTransactionManager` and `EntityManagerFactory` created by AcrossHibernateJpaModule.
In addition it will also enable <<EntityInterceptor,entity intercepting>>.

.Application module support
The application module is automatically scanned for Spring Data JPA repositories if either of the following applies:

* there is only the default `AcrossHibernateJpaModule` and property `acrossHibernate.application.repository-scan` is not `false`
* property `acrossHibernate.application.repository-scan` is `true`

WARNING: Using the default application module repository scanning is only supported with the default AcrossHibernateJpaModule.
Custom modules will usually need to provide their own mechanism as they will usually expose the required beans under a different name.

.Using default JPA repositories
It is possible to use the `@EnableJpaRepositories` instead if you manually specify the `PlatformTransactionManager` and `EntityManagerFactory`.
You will however not be able to use entity intercepting unless you also specify the custom repository factory bean.

==== Transaction management
AcrossHibernateJpaModule automatically enables transaction management in all modules.
It exposes a single `PlatformTransactionManager` and `TransactionTemplate`.
The default bean names are *jpaTransactionManager* and *jpaTransactionTemplate* respectively.

Unless the property `acrossHibernate.primary` is `false`, the exposed beans will automatically be marked as primary and an alias *transactionManager* and *transactionTemplate* will be created as well.
This is the default behaviour for the initial AcrossHibernateJpaModule.
If you want a custom module to take the primary rule - for example in a <<multiple-modules,multi-module application>> - it is important to disable primary on the AcrossHibernateJpaModule and set it to `true` on your custom module.

[[web-support]]
==== Web support
If AcrossWebModule is present and the `acrossHibernate.open-in-view` property is `true` (default), the {module-name} will automatically register either a `OpenEntityManagerInViewFilter` or a `OpenEntityManagerInViewInterceptor` bean for the `EntityManager`.

More advanced configuration options can be set using the `acrossHibernate.persistenceContextInView.*` properties.

[[unitofworkfactory]]
==== UnitOfWorkFactory
Usually the use of the <<web-support,Open EntityManager in View pattern>> and `@Transaction` annotations will suffice for simple use cases.
If however you want to manually demarcate `EntityManager` scope in your code, you can also expose a `UnitOfWorkFactory` bean.
A `UnitOfWorkFactory` allows you to easily execute a Unit of Work, code that should run in a single session.

The creation of a `UnitOfWorkFactory` is controlled through the *acrossHibernate.unitOfWorkFactory* property.
The default `UnitOfWorkFactory` only manages the `EntityManager` of the module itself.
In case of a <<multiple-modules,multi-module>> setup, you can manually create a composite using the `CompositeUnitOfWorkFactory`.

==== Using the Hibernate Session
Accessing the Hibernate `Session` directly can be done through the utility methods of the exposed `HibernateSessionHolder` bean.

[[base-classes]]
== Helper classes and utilities
In addition to the bean infrastructure, this module also provides a set of base classes and general helpers to build a persistent domain model.

=== AcrossSequenceGenerator
This is a `TableGenerator` that works cross-database and can be used to work with preset, negative id values.
Uses the `ACROSS_SEQUENCES` table created by the `AcrossSequencesInstaller` from Across core package.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
	@Id
	@GeneratedValue(generator = "seq_mm_myentity_id")
	@GenericGenerator(
			name = "seq_mm_myentity_id",
			strategy = AcrossSequenceGenerator.STRATEGY,
			parameters = {
					@org.hibernate.annotations.Parameter(name = "sequenceName", value = "seq_mm_myentity_id"),
					@org.hibernate.annotations.Parameter(name = "allocationSize", value = "10")
			}
	)
	private Long id;
----

=== Auditable entities

Any entity that implements the `Auditable<String>` interface will get auditing information set on every save or update.
`AuditableEntity` is a `@MappedSuperClass` that implements the `Auditable<String>` interface.
It adds auditing related columns: creation and last modification information (timestamp and principal).

[discrete]
==== AuditableSchemaInstaller

The `AuditableSchemaInstaller` is a base installer class that can easily be used to add the relevant auditing columns to multiple tables.

.Example entity with Auditable properties added
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----

@Entity
@Table(name = "customers")
public class Customer extends SettableIdAuditableEntity<Customer>
{
	@Id
	private Long id;

	@Column(name = "customerName")
	private String customerName;

}
----

.Equivalent AuditableSchemaInstaller to add the auditing columns in database
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Order(2)
@Installer(description = "Adds auditable columns to specific tables", version = 1)
public class MyAuditableInstaller extends AuditableSchemaInstaller
{
	@Override
	protected Collection<String> getTableNames() {
		return Collections.singleton( "customers" );
	}
}
----

Note the use of `@Order(2)` which might be necessary to ensure that your `AuditableSchemaInstaller` is run *after* running your base schema installer.

After starting your application, Across will automatically add the following columns to your entities:

|===
|Column |Type |Description |Default

|created_by
|`String`
|The name of the principal that was creating the entity
|

|created_date
|`Date`
|The time at which the object was created
|

|modified_by
|`String`
|The name of the principal that was modifying the entity
|

|modified_date
|`Date`
|The time at which the object was modified
|

|
|===

=== SettableIdBasedEntity, SettableIdAuditableEntity
Base entity classes allowing an id to be set before persisting, using the `newEntityId` property.
The `SettableIdAuditableEntity` extension will automatically have auditing information updated when `SpringSecurityModule` is active and entity intercepting is enabled (default).

The `SettableIdBasedEntity` also implements common interfaces like `IdBasedEntity`, `Persistable` and `EntityWithDto`.
These are used by many other standard modules to automatically hookup functionality.
The base implementation is sufficient for many common use cases.

.Minimal implementation of SettableIdAuditableEntity
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
	@Entity
    @Table(name = "acl_entity")
    public class MyEntity extends SettableIdAuditableEntity<MyEntity>
    {
    	@Id
    	@GeneratedValue(generator = "seq_mm_myentity.id")
    	@GenericGenerator(
    			name = "seq_mm_myentity",
    			strategy = AcrossSequenceGenerator.STRATEGY,
    			parameters = {
    					@org.hibernate.annotations.Parameter(name = "sequenceName", value = "seq_mm_myentity"),
    					@org.hibernate.annotations.Parameter(name = "allocationSize", value = "1")
    			}
    	)
    	private Long id;

    	@Override
    	public Long getId() {
    		return id;
    	}

    	@Override
    	public void setId( Long id ) {
    		this.id = id;
    	}
    }
----

=== CommonJpaRepository and IdBasedEntityJpaRepository
Shortcut interfaces to reduce code repetition.
`CommonJpaRepository` extends the basic `JpaRepository` with the `JpaSpecificationExecutor` interface.
`IdBasedEntityJpaRepository` is the extension tailored to `SettableIdBasedEntity` implementations that use a `Long` as id type.

Using these interfaces will ensure repository integration with other modules (for example `EntityModule`).

[[EntityInterceptor]]
== Entity intercepting
By default `JpaRepository` and `BasicRepository` (legacy) interfaces have their `save` and `delete` methods intercepted.
Any module can then provide an `EntityInterceptor` bean that executes code before or after the entity state is being updated.
Note that the `EntityInterceptor` listens to the repository calls and does not take into account when the actual session flushing happens (which might be at a later point in time).

All beans implementing `EntityInterceptor` will automatically be detected after their owning module has bootstrapped.
All regular Across bean ordering options apply to entity interceptors.
If you are interested in only implementing part of the `EntityInterceptor` interface you can use the `EntityInterceptorAdapter`.

.Example EntityInterceptor implementation
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
	public class MyInterceptor extends EntityInterceptorAdapter<MyEntity>
    {
    	@Override
    	public boolean handles( Class<?> entityClass ) {
    		return MyEntity.class.equals( entityClass );
    	}

    	@Override
    	public void afterCreate( MyEntity entity ) {
    		System.out.println( "A new entity has just been created!" );
    	}
    }
----

WARNING: Entity intercepting of Spring data JPA Repositories is only activated if they were created using the custom `EntityInterceptingJpaRepositoryFactoryBean`.
If you did not activate JPA repositories using the specific `@EnableAcrossJpaRepositories`, you might have to specify the factory bean class manually.

=== Known limitations
[discrete]
==== Persistable entities only
Currently `JpaRepository` methods are only intercepted if they manage a `Persistable` entity.
Reason for this is the use of the `isNew` method to determine a create or update event.
Entities extending `SettableIdBasedEntity` automatically implement the required interface.

[discrete]
==== Transactional behaviour
The `EntityInterceptor` calls happen in the same transaction as the repository method.
If no outer transaction is busy yet, a new one will be created that wraps calls like `beforeCreate`, `afterCreate` and the repository method.
The transaction manager used is the transaction manager declared in the `@EnableAcrossJpaRepositories` definition.

WARNING: When using multiple JPA modules with entity intercepting enabled, only a single transaction scope will kept.
You should pay special attention to avoid transactional issues.

[discrete]
==== Custom save/delete methods and recursive calls
The `JpaRepositoryInterceptor` implementation used intercepts only the known `JpaRepository` methods.
If for some reason you decide to create your own save or delete methods, these will not be intercepted.

Likewise calling any `save` or `delete` method from within the repository will not trigger them to be intercepted.
This is due to the standard proxy behaviour.

[[multiple-modules]]
== Multiple EntityManagers
A single AcrossHibernateJpaModule represents a single `EntityManager` attached to a single datasource.
If you require multiple `EntityManager` instances you can use AcrossHibernateJpeModule as a base for a new module.

A couple of things noteworthy:

* every instance creates its own `EntityManager` and builds its own mapping context
** modules will need to specify separately which entities they want to register in which mapping context
* every instance has its own set of <<module-settings,settings>> used for configuration
* every instance exposes at least its own `EntityManagerFactory`, `PlatformTransactionManager` and `TransactionTemplate`
** you should ensure that one of each is preferably marked as primary, see property `acrossHibernate.primary`
** you should ensure all of them are exposed under a unique name to avoid conflicts (eg. by prefixing them using an `ExposedBeanDefinitionTransformer`)

An application usually has to take special care when working in a configuration with multiple JPA modules.
Usually the default AcrossHibernateJpaModule will be set as primary and additional modules only used explicitly.

There are 2 ways to create additional JPA modules:

* create a custom module at runtime
* extend AcrossHibernateJpaModule to create a separate shared module

=== Runtime JPA module
Creating a separate JPA module at runtime is very convenient, especially when only required in a single application.
You can easily create a custom module using the `AcrossHibernateJpaModule.builder()`.

As a minimum you should specify a unique prefix for that module, which will be used to generate the rest of the configuration options.

.Example runtime JPA module and datasource
[source,java]
----
@Bean
@ConfigurationProperties("app.datasource.my")
public DataSourceProperties myDataSourceProperties() {
    return new DataSourceProperties();
}

@Bean
@ConfigurationProperties("app.datasource.my")
public DataSource myDataSource() {
    return myDataSourceProperties().initializeDataSourceBuilder().build();
}

@Bean
public AcrossHibernateJpaModule myJpaModule() {
    return AcrossHibernateJpaModule.builder().prefix( "my" ).build();
}
----

The above example defines a separate datasource which reads the properties `app.datasource.my` and creates the `DataSource` bean called `myDataSource`.

The custom `AcrossHibernateJpaModule` is built using only the prefix *my*, which results in the following:

* the generated module name will be `MyJpaModule`
* all properties starting with `my.jpa` will be considered configuration properties for that module (eg. `my.jpa.generate-ddl=true`)
* a datasource bean named *myDataSource* will be expected as the datasource for the mapping context
* exposed beans will be prefixed with `my`, resulting in `PlatformTransactionManager` being exposed as *myJpaTransactionManager*

The `AcrossHibernateJpaModuleBuilder` allows customizing all options of your module separately.
See the javadoc or source code for all details.

Entities should be attached explicitly to the separate mapping context:

.Registering entities for the runtime JPA module
[source,java]
----
@ModuleConfiguration("MyJpaModule")
@EntityScan(basePackageClasses = MyEntity.class)
public class MyEntitiesRegistrar
{
}
----

Likewise, using Spring Data JPA repositories requires you to configure them manually with the correct `PlatformTransactionManager` and `EntityManagerFactory` reference.

.Enabling the Spring Data JPA repositories in your module
[source,java]
----
@Configuration
@EnableAcrossJpaRepositories(
  transactionManagerRef = "myJpaTransactionManager",
  entityManagerFactoryRef = "myEntityManagerFactory"
)
public class MyEntitiesConfiguration
{
}
----

This way, it would be perfectly possible for `MyJpaModule` to be present alongside any number of other `AcrossHibernateJpaModule` instances.

=== Shared JPA module
If you want to create a new shared module building a different `EntityManager`, you can extend `AcrossHibernateJpaModule` and customize some settings.

.Custom shared module
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public class CustomConnectorModule extends AcrossHibernateJpaModule
{
	public static final String NAME = "CustomConnectorModule";

	public CustomConnectorModule() {
		setPropertiesPrefix( "customConnector" ); <1>
		setExposeTransformer( new BeanPrefixingTransformer( "custom" ) ); <2>
		setPrimary( true ); <3>
	}

	@Override
	public String getName() {
		return NAME; <4>
	}
}
----

<1> Configure a separate properties prefix.
All properties starting with `customConnector` will be considered configuration properties for this module (eg. `customConnector.generate-ddl=true`)
<2> Unique prefix to be added to the exposed beans.
In this case the `PlatformTransactionManager` will be exposed as *customJpaTransactionManager*
<3> Explicitly set this module primary.
Do this only in the case where you want this module to always expose the primary transaction manager.
When combining with AcrossHibernateJpaModule in the same application, it is also important to unset the default module primary status.
You can always omit this and set the primary status using the corresponding property value instead.
<4> As with any custom Across module, provide it a unique name.
Providing the `public static final String NAME` allows the module to be scanned by name.

If you easily want to generate Spring Boot configuration metadata for your custom properties, you could additionally extend `AcrossHibernateJpaModuleSettings` and register a seperate `@ConfigurationProperties`.

.Build Spring Boot configuration metadata for the *customConnector* properties
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@ConfigurationProperties("customConnector")
public class CustomConnectorModuleSettings extends AcrossHibernateJpaModuleSettings
{
}
----

Registering entities or activating Spring Data JPA repositories is done in exactly the same way as with a separate runtime JPA module.

Using a fully custom shared module also allows you to add additional configuration to your module.
